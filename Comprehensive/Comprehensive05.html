<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS 深入部分练习</title>
    <H1>JS 深入部分练习</H1>
</head>
<body>
    
    <script type="text/javascript">

//练习01———————————————————————————————
console.log("练习01——————————————————")
    //画出以下函数的运行过程
    let a = 123

    function abc(){
        let a= 100
        return function(x){ //🌟🌟相当于定义了一个匿名函数！
            a += x // a = a + x 
            console.log(a)
        }
    } 

    const c = abc() //c = return function(x){}的函数!!
    c(200) //相当于 c 去执行 function(x)! // a = 100+200=300  
    c(600) //这里有个坑！🌟🌟因为上一步 a = 300 了，然后继续 300+600=900!!
    
    const d = abc()//🌟🌟🌟🌟大坑！！这个会产生一个新的 abc()！！上面的函数执行完后就被回收了！
    d(600)// a=100+600=700🌟🌟🌟
    console.log('结束了')


//练习02———————————————————————————————
console.log("练习02——————————————————")
    //判读以下函数依次输出的是什么
    function fn(){
        let a = 0
        // a = 0 ,如果不用 let & const 来定义的话， a 会被提升到全局！这样的话下面就不会产生闭包对象！因此每次 a都会+1
        return function(b){  
            return b + a++; //🌟🌟a++为整个代码执行完后再去++ //🌟🌟function(){}这个函数有个闭包对象 a=0 ！！，因为用到了 a 来算表达式
            //闭包对象：a=0+1=1
        }
    }
    var f = fn() //f = function(b){}
    console.log(f(5))//5+0=5
    console.log(fn()(5))//5   //🌟🌟相当于重新执行 f(5)，跟之前不是一个f(5)！！ //🌟🌟🌟🌟大坑！！这个 fn() 将产生一个新的闭包对象！！
    console.log(f(5))//6   //🌟🌟🌟🌟大坑！！这个时候 return 函数内的 a++ 了，所以变成 1
    console.log(a)//Undefined


//练习03———————————————————————————————
console.log("练习03——————————————————")
    //判读以下函数依次输出的是什么
    function test2(){
        setTimeout(function(){
            console.log(1)
        },0)
    }

    function log(){
        console.log(3)
        setTimeout(function(){
            console.log(5)
        },0)
    }
    setTimeout(function() {
        console.log(2)
    },0)

    log()
    test2()
    console.log(4)
    
    //3
    //4
    //2 //🌟遗留小疑问，问什么异步的 2 比 5 早执行？
    //5
    //1


//练习04———————————————————————————————
setTimeout(function() {
    console.log("练习04——————————————————")
    },0)

    //判读以下函数依次输出的是什么
    var test002 = (function(i){ //i=2
        return function(){ //i=2
            console.log( i *= 2 ) //i=2X2=4
           }
        })(2) //🌟🌟🌟这是立即执行函数的写法！！立刻传入 2


    setTimeout(function() {
        test002(5) //🌟🌟🌟因为 return 的 function()没有参数！！所以这个 5 没传进子函数！！
    },0)
    
    //4
    


//练习05———————————————————————————————
setTimeout(function() {
    console.log("练习05——————————————————")
    },0)

    setTimeout(function() {
    //将下面的函数进行深拷贝

    //思路：用到递归,只要是对象就重复调用去需要判断一个对象内的 key 是不是个对象；
    const obj = {
        a:123,
        b:{
            x:456,
            y:{
              t:'是我'
            }
        },
        c:true,
    }

    function Check(x){
        const Result = {} //第一步就是建立要拷贝到的对象
            
            Object.keys(x).forEach((yy,index)=>{ //第三步，用 Object 原型方法来找出对象的 key, 这里的 yy 为 key ,配合 Obj.key 能够获得值 value
                if(typeof x[yy] === "Object"){ //第四步，判断 key 是不是 "Object"
                    Result[yy] = Check(x[yy])   //每次递归都会产生一个新的活动对象跟执行环境对象
                }   
                else{
                    Result[yy] = x[yy]
                }
            })
        return Result //第二步就是要返回这个对象
    }

    console.log(Check(obj)!==obj)
    



//练习06———————————————————————————————
console.log("练习06——————————————————")

    //实现一个函数，不管传入多少数据(数字）都能加总起来并进行返回
    //分别用剩余参数收集符跟 arguments 实现

    //arguments 的实现方法
    function AddNum(x){
        let arr = Array.from(arguments) //先把传入的数据生成一个数组
        let result = arr.reduce((a,b) => a+b, 0)
        return result
    }

    console.log(AddNum(1,2,3,4,5))







    },0)
    </script>

</body>
</html>