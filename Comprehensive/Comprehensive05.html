<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS 深入部分练习</title>
    <H1>JS 深入部分练习</H1>
</head>
<body>
    
    <script type="text/javascript">

//练习01———————————————————————————————
console.log("练习01——————————————————")
    //画出以下函数的运行过程
    let a = 123

    function abc(){
        let a= 100
        return function(x){ //🌟🌟相当于定义了一个匿名函数！
            a += x // a = a + x 
            console.log(a)
        }
    } 

    const c = abc() //c = return function(x){}的函数!!
    c(200) //相当于 c 去执行 function(x)! // a = 100+200=300  
    c(600) //这里有个坑！🌟🌟因为上一步 a = 300 了，然后继续 300+600=900!!
    
    const d = abc()//🌟🌟🌟🌟大坑！！这个会产生一个新的 abc()！！上面的函数执行完后就被回收了！
    d(600)// a=100+600=700🌟🌟🌟
    console.log('结束了')


//练习02———————————————————————————————
console.log("练习02——————————————————")
    //以下函数依次输出的是什么
    function fn(){
        let a = 0
        // a = 0 ,如果不用 let & const 来定义的话， a 会被提升到全局！这样的话下面就不会产生闭包对象！因此每次 a都会+1
        return function(b){  
            return b + a++; //🌟🌟a++为整个代码执行完后再去++ //🌟🌟function(){}这个函数有个闭包对象 a=0 ！！，因为用到了 a 来算表达式
            //闭包对象：a=0+1=1
        }
    }
    var f = fn() //f = function(b){}
    console.log(f(5))//5+0=5
    console.log(fn()(5))//5   //🌟🌟相当于重新执行 f(5)，跟之前不是一个f(5)！！ //🌟🌟🌟🌟大坑！！这个 fn() 将产生一个新的闭包对象！！
    console.log(f(5))//6   //🌟🌟🌟🌟大坑！！这个时候 return 函数内的 a++ 了，所以变成 1
    console.log(a)//Undefined


//练习03———————————————————————————————
console.log("练习03——————————————————")











    </script>

</body>
</html>