<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>综合练习(数组)</title>
    <H1>综合练习(数组)</H1>
</head>
<!-- <H1>综合练习(数组)</H1> -->
<body>
    <script type="text/javascript">

//—————————————————————— 练习1 ——————————————————————————
console.log("—————————————————  练习1 ——————————————————")

//定义一个构造函数，一个参数，new 一个实例
//利用上面的数据产生一个新数组！（所以不是 sort)，数组中都是构造函数的实例，实例 age 分别为 arr 这个数组中的数据
//最终数组中的对象顺序要按照 age 属性的大小进行生序排列
let array = [12,41,20,66,35,70]

//修改原数组的写法
// function person (age) {
//     this.age = age
//     let result = age.sort(function compare(a,b){
//         return a - b
//     })
//     return result
// }

function person (age) { //传入 array 数组
    this.age = age
}
  
let result = array.map((x) => { //定义一个变量，用 map 方法把数组的数据镜像出来，用这个变量来接收结果
        return new person(x) //返回构造函数，每次都提取出一个数据
    }).sort((a,b) => a.age-b.age) //返回的数组再来排序（链式写法
    
console.log(result)






//—————————————————————— 练习2 ——————————————————————————
console.log("—————————————————  练习2 ——————————————————")

//比较两个数组中有没有相同的值
//定义一个函数，有两个参数，分别传入两个有数据的数组并进行比较，有严格相同的数据的话则返回 true，没有则返回 false

const array1 = ['海鲜','炒饭','辣椒','土豆泥']
const array2 = ['小米粥','土豆泥','牛柳','包菜']

function compare(arr1, arr2) {

const result2 = arr1.findIndex((a,b) => {// 先提取出数组 1 的值,定义一个函数接收内层函数返回的结果
    const result = arr2.findIndex((a2,b2) => { //定义一个变量接收对比的结果,有则为对应的元素 ,没有则为 -1
        return a === a2}) //🌟很关键，每次回调的函数中都比较数组 1 中找到的值与 2 中找到的值相不相同
        if(result === -1){
            return false //内层回调函数的结果
        }else{
            return true //内层回调函数的结果
        }
    })
    if(result2 === -1){ // result2 = 内部函数的 return 结果
        return false //外层回调函数的结果
    }else{
        return true //外层回调函数的结果
    }
}

console.log(compare(array1,array2))





//—————————————————————— 练习3 ——————————————————————————
console.log("—————————————————  练习3 ——————————————————")

//定义一个【函数】，可以传入一个【数组】跟【字符串】，执行时筛选出低于 80 分的对象
//然后给对象设置一个属性叫 label，这个属性的值就是传入第二个参数的【字符串】
//同时用深拷贝的方式创建一个新的数组，把原数组用相反的方式复制到新的数组中

let array3 = [
    {name:'小明',score:60},
    {name:'小花',score:59},
    {name:'小亮',score:98},
    {name:'小李',score:88},
    {name:'小章',score:57},
    {name:'小钟',score:42},
    {name:'小陈',score:92},
    ]

function rankin(arr,str) {
    let temp = array3.filter(x => x.score <= 80) //x 加不加括号都可以

    temp.forEach((x) => x.label = str) //🌟🌟🌟，遍历之后添加 label 这个属性进去! 这个会加到原数组中去，因为是浅拷贝！
    
    arr.reverse()//反转数组

    const rersult = arr.map( (x) => { //映射，复制出一个新数组
        return {   //map 会返回一个新数组， return 后就是这个返回的数组
            ...x   //拓展运算符！！🌟🌟，返回所有值
        }
    })
    return rersult

}

console.log(rankin(array3,'下次努力') === array3) //不是同一个数组






//—————————————————————— 练习4 ——————————————————————————
console.log("—————————————————  练习4 ——————————————————")

//计算某个元素在数组内的总数

//定义一个函数，传入两个参数，第一个为数组，第二个为某个数据，执行时传入对应的数组和数据
//筛选出数【组内】有多少个和你【传入的数据】【相等】的数据，统计总数，返回数量

let array06 = [
                [1,2,3,'well',12,'6',true,'apple',],
                [1,2,'火箭',12,'空间站','apple', 12, 'banana','6', 'guava'],
            ]

function total (arr,y){
    let array07 = [] //用来承接筛选出来的数据的数组

    arr.forEach( x => {   //这里的 x 代表一个遍历出来的两个数组
        
        const temp = x.filter( item => item === y )   //筛条件，会返回对应的【新数组】,定义一个【变量】去接收它
        
            array07 = [...array07,...temp]  //🌟🌟🌟每次都把 for each 筛选出来的值都放到 array 07 这个数组中
     
    })   
    return array07.length //表示数组的长度，也就是说有多少个结果
}

console.log(total(array06,2))





//—————————————————————— 练习5 ——————————————————————————
console.log("—————————————————  练习5 ——————————————————")

const array0007 = [1,2,3,4,5,6,7,8,9,10]
//根据这个数组创建一个新的数组，这个新数组每一位都是（原数组索引位的值）与（下一位索引位的值）
//如果是最后一位索引位，则是与和第一位索引位的和

//🌟根据原数组产生新数组的情况下大部分都是 map

let result2 = array0007.map((x,y,z)=>{
    if (y === array0007.length - 1 ){ //当索引位为最后一位时
        return y + 0 //返回最后一位+第一位，第一位一定是 0
    } else {
        return y + y + 1 //下一位索引位的值
    }
})

console.log(result2)




//—————————————————————— 练习6 ——————————————————————————
console.log("—————————————————  练习6 ——————————————————")


//定义一个函数，一个参数，可以把传入的数组按照不同的数据类型进行处理
//如果是数字类型，把所有数字相加，
//如果是字符串，把字符串拼接到一起
//如果是其他类型则忽略
//加总的数字和拼接的字符串都需要添加回原数组的最后面
//返回原数组

let array009= [1,2,3,'a','d','s',true]

function Sum ( arr ){
    let NumTotal = 0     //一个用来承接数字的加总,初始化为 0
    let StrTotal = ''    //一个用来承接字符串加总,初始化为 1
    arr.forEach((x)=>{
        
        if( typeof x === 'number' ){
            NumTotal += x    //🌟🌟遍历出来的字符串相加，用 +=
        } else if   ( typeof x === 'string' ){
            StrTotal += x     //🌟🌟遍历出来的数字相加，用 +=
        } 
    })
    array009.push(NumTotal,StrTotal)   //两个一起加

    return arr
}

console.log(Sum(array009))





//—————————————————————— 练习7 ——————————————————————————
console.log("—————————————————  练习7 ——————————————————")


//定义一个函数，可以传入一个字符串，可以把字符串拆分成一个个字符，用倒序放入一个数组内并返回

function Separate(x){

    let arr000 = [1,2]

    for(let item of x){
        arr000.push(item) //这样每次读出来一个字都会 push 到数组末尾
    }
    return arr000.reverse() //反转一下
}
console.log(Separate('老弟'))




//—————————————————————— 练习8 ——————————————————————————
console.log("—————————————————  练习8 ——————————————————")


//定义一个函数,两个参数,能传入一个 [数组] 跟 [类型数据]
//函数执行时,判断数组里边有没有 string、number 类型的数据
//有 string、number 类型的数据的话,就把所有数据变成这个类型
//如果没有该类型的数据的话,就把数组清空
//最后返回这个原始数组

const MixArr = [1,2,'火箭',true]
const MixArr2 = [false,true]

function decision (x,y) { // x 为数组, y 为不同类型的值

    const istype = x.some(ele => typeof ele === y)

    if (istype) { //为 true
        x.fill(y) //填充数组为 y 这种类型的数据
    } else {
        x.length = 0
    }
    return x
}

console.log(decision(MixArr,"string"))





//—————————————————————— 练习9 ——————————————————————————
console.log("—————————————————  练习9 ——————————————————")

//定义一个函数,两个参数,能传入一个 [数组] 跟 [类型数据]
//函数执行时会把[原数组]中[所有][非]这种类型数据的数据都删除掉 -> 搜集出这些数据然后匹配后进行删除
//被删除的数组会组成一个[新数组]
//返回这个被删除的[新数组]
let arr010 = [1,2,'3','d',6,true,'b',9,23]

function desicionArr (arr,type){
    const indexArr = [] //用来承接哪个位置需要裁切
    let Count = 0; //初始值为 0 ,每次裁切数据后都会少一位
    const resultArr = []//用来承接 splice 裁切出来的数据

    arr.forEach((a,b)=>{ //遍历出 arr 的索引位置, b 相当于索引位
        if ( typeof a !== type) //不是 y 这个类型
            indexArr.push(b)  //🌟🌟把不是的这些索引位添加到 indexArr 这个空数组中 (这个数组变成一个索引位), 然后对比两个数组来用 splice 裁切
    })

    indexArr.forEach((c)=>{  //遍历出它的索引位, 因为上一步存进去的是索引位,所以这里遍历出来就是索引位
        resultArr.push(...arr.splice(c-Count,1)) // splice 需要用索引位去切,每次裁切数据后都会少一位,1 表示每次裁 1 位
        //👆用上面的空数组来承接 splice 返回的新数组
        Count++  //每删掉一位数据就 +1    
    })
    console.log(arr) //剩下的数组
    return resultArr
}

console.log(desicionArr(arr010,'number')) //裁掉的数据




//—————————————————————— 练习10 ——————————————————————————
console.log("—————————————————  练习10 ——————————————————")

//定义一个函数,传入一个数组,可以计算出数组中所有数字类型数据的总和的值
//并把所有非数字类型的数据组成一个新的数组并返回
//🌟instanceof Array 用来判断一个数据内包不包含数组!🌟
let arr011 = [
                1,
                [1,2],
                5,
                [6,'true',1],
                [6,10],
                false,
                            ]

function Result (CountArr) {
    let total = 0; //用来承接加总的值,每次拿出一些数字都计算一下值
    let newArr = []//用来承接遍历出来的[非数字类型]的的值

    arr011.forEach((ele)=>{
        if (typeof ele ==="number") {
            total += ele
        } else if ( ele instanceof Array ) { //判断是不是数组
            ele.forEach((yyy)=>{  //如果是数组则遍历它里边的数字,注意这里是 ele ! 遍历出来的 ele = [数组!]
                if(typeof yyy === 'number') {//数组内的数组遍历完后,是否有[数字]
                    total += yyy
                }else {
                    newArr.push(yyy) //上面已经把 ele 内含有数字的加总起来了, 剩下的就是不是数字的 ele, 然后全部放到空数组中
                }
            })            
        }else {
            newArr.push(ele) //其他的也一起丢进空数组中
        }

    })
    console.log(total,newArr)
    return newArr //返回对象
}
Result(arr011)

    </script>
</body>
</html>