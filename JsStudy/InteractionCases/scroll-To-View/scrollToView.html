<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>视窗触发事件</title>
</head>
<body>
    <h1 class="h1">视窗触发事件</h1>
    <h2>啦啦啦</h2>
    <div class="box">我是被观察对象</div>
    <p>我是一段内容我是一段内容我是一段内容我是一段内容我是一段内容我是一段内容</p>
    <!-- 
        传统的方法：
            Element.getElientBoundRect    计算元素与浏览器[显示窗口]顶部的距离的差值,看是否 < 元素本身的高度


        现在的方法：
            Why?
                对性能损耗比较小

            What？
                 IntersectionObserver       交叉观察器(本质是一个构造函数)
                【被观察元素】与【视窗】或者【父级元素】的【相交区域】
                
            How?
                可以定义一个监听器，监听 【root: XXX 这里定义的对象】与【被观察元素】的【相交区域】
                可以设置相交的比例, 比如相交的比例是 0.5, 就是超过元素的一半
 
     -->
    
</body>


<style>
    html{
        overflow-x: hidden;

    }
    body{
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    .box {
        width: 200px;
        height: 200px;
        background-color: #000000;
        transform: translateY(1200px);
    }
    p{
        transform: translateY(1400px);
    }
</style>



<script type="text/javascript">

    const box = document.querySelector('.box');

    

// 👇 创建交叉观察器
    function callback(entries){ //一般就定义为 entries ，如果要使用着参数的话，那需要定义好这个 行参 的位置，因为回调函数回自动传入这个实参
        console.log('进入视窗了')
        console.log(entries)//会返回回调函数 IntersectionObserverEntry 数组对象

        entries.forEach(item => {
            console.log(item)

            // 🌟🌟🌟 item 里边包含的数据
                //time                  可见性发生变化的时间，是一个高精度的时间戳，精度为毫秒
                //target                被贯彻目标元素，是一个 DOM 节点对象
                //rootBounds            根元素的矩形区域的信息， getBoundingClientRect() 方法的返回值，如果没有根元素（即直接相对于视口滚动）
                //boundingClientRect    被贯彻目标元素的矩形交叉区域的信息
                //intersectionRect      交叉区域的矩形区域的信息
                //intersectionRatio     目标元素与交叉区域的可见比例（即 intersectionRect 占 boundingClientRect 的比例），完全可见时为 1，完全不可见时 <= 0
        })
    }



    const options = {
        // root:null, //需要被相交的元素，比如元素的父级（或参照目标），默认设置的话就是以【视窗】为相交目标
        rootMargin:'5px 2% 0px 0px', //这个一定要带单位! 可以改变相交区域的位置(相当于给它加上、右、下、左的 margin），一定要带单位, 如果相交目标是浏览器窗口的为参照的话，一定要带百分比(🌟-50%就是窗口的一半!)。（ + 正值向外延伸， - 负值向内缩小）
        threshold: [0.5,0.75] //相交的比例（0～1）的范围，还可以传数组，设置多个比例，比如[0.2, 0.4, 0.6],每达到某个比例的话都会促发
    }

    const observer = new IntersectionObserver(callback,options) //创建一个观察器实例,🌟🌟顺序要放在下面!!

//👇调用观察器
    observer.observe(box) //用 observer 的实例去调用 observer 的方法


</script>


</html>
