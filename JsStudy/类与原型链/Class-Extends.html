<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>类的继承</title>
    <H1>类的继承</H1>
    <!-- 
    Class 复习
        🌟🌟原型方法可以用 [实例] 来调用
        🌟🌟静态方法(static)得用 [类] 来调用

        原型方法比如车的百米加速度、自动挡还是手动挡是不同的
        静态方法比如一类车的品牌是固定的

    Extends
        What
            类之间需要有的属性或方法的继承
            子类(or 派生类)继承父类(基类、超类)
            派生类如果不写 constructor 方法, 就会调用基类的 constructor ,基类的(constructot)属性跟方法派生类也都有
        
        How
            🌟 写法一:函数式写法
                    class XX extends 父类 {

                    }

            🌟 写法二:表达式写法
                    const Apple = class extends XXX {

                    }

           

    Super()
        What
            是什么?   
                1.执行符,指向父类的关键字;
                2.只会出现在子类中;
                3.不能单独引用 super()
                4.🌟 子类写了 constructor 后一定要写 super(), 子类写了 constructor 的参数后也一定要在 super 里边写上!
                5.实例化后,实例的参数都会传入给这个手动调用 constructor 的 super(),子类得手动传参
                6.如果派生类中「显示定义(相当于原型方法?)」了构造函数的话,那么必须在其中调用 super(),要么必须在其中 return 返回一个对象
            
            作用是:
       /    一、子类可以调用父类的静态方法, 子类的实例会同时具备父类跟子类的特性
            二、🌟🌟子类也可以用 super 来访问父类的原型方法!
            三、🌟🌟子类也可以用super 来访问父类的静态方法!
        How
            🌟 写法一:函数式写法
                    class XX extends 父类 {
                        constructor(x,y){
                            super(x,y)

                        }
                        XX(){
                            super.XXX
                        }

                        static XX() {
                                super.XXX
                            }   
                    }


    -->
</head>
<body>
    <script type="text/javascript">
    
   
    

    class Cat{   //父类、基类
        constructor(name,age,fn){
            this.name = name
            this.age = age
            this.action = fn
        }
        miao(){
            console.log("miaomiao")
        }
        static species = ['British','China','Japan','USA']
        static run() {
            console.log("running")
        }
    }




    class ChinaCat extends Cat {    //🌟子类 or 派生类: 集成了 Cat 这个父类
        constructor(x,y,z,type){
            super(x,y,z,type)     // 🌟🌟子类写了 constructor 的话第一时间要写上 Super! 
            this.type = type     //🌟子类独有的方法
        }
        原型方法(){
            super.miao() //🌟🌟子类也可以用 super 来访问父类的原型方法!
            console.log("我是派生类的原型方法")
        }
        static hello() {
            super.species //访问父类的静态方法
            console.log(super.species[2])  //🌟🌟子类也可以用super 来访问父类的静态方法!
            console.log("我是派生类的静态方法")
        }
    }


    
    //创造一个实例,继承父类的属性以及具备子类的特性
    const chinaCat001 = new ChinaCat('嘟嘟',2,function(){console.log("起飞了")},'China')
    
    console.log(chinaCat001)


console.log("————————————————————————————")
    chinaCat001.原型方法()
    ChinaCat.hello()




console.log("—————————————— 练习 ——————————————")

//定义一个类型,可以传入 3 个参数, 2 个原型方法, 1 个静态方法
//该类型的实例有 3 个属性, 属性值分别为调用改类型 new 的时候传入的 3 个参数
//然后基于这个类型定义一个派生类, 该派生类的实力者具备 2 个属性, 也可以通过 new 传入, 作为该类型实例的这 2 个额外属性的值
//同时该派生类药有 1 个自己的原型方法, 以及 1 个自己的静态属性
    
    
    class Person {
        constructor(eyes,hands,brain){
            this.eyes = eyes;
            this.hands = hands;
            this.brain = brain;
        }

        run(){
            console.log("100km/h")
        }
        read(){
            console.log("10000word/h")
        }
        static says(){
            console.log("hello")
        }
    }
    
    //原生人
    const Jimmy = new Person('big','stong','smart')
    console.log(Jimmy)

    //派生类

    class Smart extends Person {
        constructor(eyes,hands,brain,x,y){
            super(eyes,hands,brain,x,y)
            this.x = x;
            this.y = y;
        }
        swim(){
            console.log("50km/h")
        }
        static speaks(){
            console.log("language/eng")
        }
    }

    //派生人
    const Zen = new Smart('big','stong','smart','hello','world')
    console.log(Zen)




//定义三个类型,一个父类,一个孙类, 父类至少两个属性, 每个子类型实例上的属性要比上一层类型的实例多一个

class Food {
        constructor(Calories,Sugar){
            this.Calories = Calories
            this.Sugar = Sugar
        }
    }

    class Water extends Food {
        constructor(Calories,Sugar,Vitamins){
            super(Calories,Sugar,Vitamins)
            this.Vitamins = Vitamins
        }
    }
    
    class Soda extends Water {
        constructor(Calories,Sugar,Vitamins,Fat){
            super(Calories,Sugar,Vitamins,Fat)
            this.Fat =Fat
        }
    }

    const 喜小茶 = new Soda(1000,10,0.05,0)
    console.log(喜小茶)










    </script>
    


    
</body>
</html>