<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>类的继承</title>
    <H1>类的继承</H1>
    <!-- 
    Class 复习
        🌟🌟原型方法可以用 [实例] 来调用
        🌟🌟静态方法(static)得用 [类] 来调用

    Extends
        What
            类之间需要有的属性或方法的继承
            子类(or 派生类)继承父类(基类、超类)
        
        How
           🌟 在子类中写 XX extends 父类

           派生类如果不写 constructor 方法, 就会调用基类的 constructor ,基类的(constructot)属性跟方法派生类也都有

    Super()
        What
            是什么?   
                1.指向父类的关键字,
                2.只会出现在子类中,
                3.不能单独引用 super()
                4.🌟 子类写了 constructor 后一定要写 super(), 子类写了 constructor 的参数后也一定要在 super 里边写上!
                5.实例化后,实例的参数都会传入给这个手动调用 constructor 的 super()
                6.如果派生类中「显示定义(相当于原型方法?)」了构造函数的话,那么必须在其中调用 super(),要么在其中返回一个对象
            
            作用是:
            一、调用父类的静态方法
            二、🌟🌟子类也可以用 super 来访问父类的原型方法!
            三、🌟🌟子类也可以用super 来访问父类的静态方法!
        How
            
            XX extends 父类 {
                constructor(x,y){
                    super(x,y)
                }
             }



    -->
</head>
<body>
    <script type="text/javascript">
    
   
    

    class Cat{   //父类、基类
        constructor(name,age,fn){
            this.name = name
            this.age = age
            this.action = fn

        }
        miao(){
            console.log("miaomiao")
        }
        static species = ['British','China','Japan','USA']
        static run() {
            console.log("running")
        }
    }





    class ChinaCat extends Cat {    //🌟子类 or 派生类: 集成了 Cat 这个父类
        constructor(x,y,z,type){
            super(x,y,z,type)     // 🌟🌟子类写了 constructor 的话第一时间要写上 Super! 
            this.type = type     //🌟子类独有的方法
        }
        原型方法(){
            super.miao() //🌟🌟子类也可以用 super 来访问父类的原型方法!
            console.log("我是派生类的原型方法")
        }
        static hello() {
            console.log(super.species[2])  //🌟🌟子类也可以用super 来访问父类的静态方法!
            console.log("我是派生类的静态方法")
        }
    }



    const chinaCat001 = new ChinaCat(
        '嘟嘟',2,function(){console.log("起飞了")},'China'
        )
    
    
    console.log(chinaCat001)
    chinaCat001.原型方法()
    ChinaCat.hello()
    
    
















    </script>
    


    
</body>
</html>